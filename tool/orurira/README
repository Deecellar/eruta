
  +---------+
  | ORURIRA |
  +---------+
    
  Introduction
  ============
  
  Orurira stands for Orurira is a Ruby Rike Ranguage. Sorry for that joke. ^_^
  The goal of this project is to create a specification of, and a compiler for compiler for a lanuage that is as close to Ruby as possible, limited only by 
  the imperative that everything in the language can compile down to real 
  machine code, without the use of any VM.  The main of goals of the Orurira 
  compiler will be Flexibility, Simplicity, Speed and Compatibility with Ruby.
  
  Orurira, as a language, will be 100% compatible with Ruby's syntax, without 
  any extensions or emissions to it. However, differences in semantics as well 
  as in in functionality will be deemed acceptable if compilation of these 
  features is difficult. For example, "eval"-like constructs will not be 
  supported initially. 
  
  The rest of this README is more a explanatory and planning document than the 
  current state of things. I hope the kind reader will bear with me.
  
  
  How Orurira will implement Ruby
  =============================== 
  
  When writing a compiler for a high level language, the problem is that many 
  low level primitives need to be implemented to support the high level 
  constructs. In other Ruby implementations, these primitives are are 
  implemented in C, C++, Java, or  assembly, but that is unsatifactory for many reasons. On the other hand, it's conceptually difficult to let Ruby generate 
  the primitives it needs for itself. 
  
  The Ruby to C project is a very useful idea, but still, it is limited in that 
  it compiles Ruby down to C. This means that you're still bound to the C 
  calling conventions, and limited to C's capabilities. That's why I think 
  trying to write primitives for Ruby in a C environment is much like trying 
  to push a square peg in a round hole. It's never a nice fit.
  
  For all these reasons, Orurira as a language, will suport two different modes,
  or dialects if you like. The first dialect is simply the "Ruby" dialect, 
  where the second one is the low level "Alox" dialect.
  
  In the Ruby dialect the semantics of Ruby will be followed as closely as is technically feasible.  The Ruby dialect is enabled by default. For it's support, it uses primitives  that must have been defined in Alox mode.   
  
  The second dialect in Orurira will be the Alox language mode. (Alox stands for
  ALuminum OXide, of which rubies are made. Sorry for this joke, again. ^_^) 
  In the Alox dialect, the syntax is still that of Ruby, but the semantics are
  signicficantly different. Alox is, in a way, a domain specific language that 
  can be used to generate primitivesf for the Ruby mode. But it would be more 
  fair to say that Alox is intended is a dialect of Ruby which is generally 
  useful for low level programming.
  
  Alox
  ====
  
  Alox language mode is started by writing "alox true", or just Alox by 
  itself at the beginning of a source file. It's turned off again by saying 
  alox false. You can also do alox do ... end.
  
  Alox has the following differences in semantics with Ruby:
   
  * Alox is a statically typed language with type inference. 
  * Contrary to Ruby, Alox is an imperative language.    
  * Constants cannot be looked up or caclulated dynamically. They do support
    integer expressions. Also some simple string or symbol expressions are 
    allowed. And they are also used for defining records and namespaces.
  * Namespaces are supported like this :Foo = namespace do ... end.   
  * A def foo(a, b) ... ; outside a class of module generates a real low level
    primitive function.
  * Outside of defs, if, case, while and other control structs are only 
    supported for macro-like features.
  * Types are inferred from the parameters of the functions if you give them
    default values. Otherwise, it's inferred from assignments. You can also 
    define the type of a variable foo by saying "type :foo, Typename".
  * Several built-in types are supported.
  * Alox::Byte is usually 8 bits wide, however on some unusual platforms, a 
    byte may be defined as 6,7, or even 9 bits wide.
  * Alox::I<n> : where n is 1, 2, 3, 4, 8: an integer that takes up exactly 
    n bytes in the CPU's memory.
  * Alox::Int is an Alox::I of of platform-specific guaranteed 
    to be the fastest integer usable on this platform that could be used to also contain a data address. All literal integers in  Alox mode are of this type 
    by default, unless if they are too big to fit. In the latter case, see Alox::I<n>.
  * Alox::U<n>. Unsigned integer types.
  * Alox::Size. Unsigned integer large enough to contain an address, also large
    enough for a maximal size offset(hence the name). Alox::Uint is a synonym.
  * Alox::Float. A floating point of double precision. Size is platform-specific
    It guarantees at least 64 bits of precision. All literal floats are of that type.
  * Alox::Boolean for true, false. Booleans may be set to nil, which is the same 
    as setting them to false.
  * Strings are supported, but only as constant, literal byte strings. 
    More capable strings must be implemented in Alox itself (like strlib in C).  
  * Alox::Address is an address of a low level functuion, stacla, array or 
    string. The value nil is always an address. It may also be set to nil.
  * Arrays are supported, but only homogenous arrays of Alox::Byte, Alox:I<n>,
    Alox::Int, Alox::U<n>, Alox::Size or Alox::UInt, Alox::Float, Alox::Address.
    Arrays can be resized dynamically, which will be compiled to heap memory
    allocation if needed. An arrays is of the type array of Alox::Int by 
    default. Generic arrays are not directly supported.
  * Nil is special: Setting an (unsigned) integer value to nil sets it to a 
    platform  dependant value (perhaps 0). Floats are set to NAN. Booleans 
    to false. Addresses to the special NOWHERE address.
  * Address and Int can be connverted to each other without loss of data. 
    Arrays of Address and Int are compatible with each other.
  * Symbols are only supported in special constructs. Otherwise, they are 
    compiled as byte strings. This limitation is imposed so symbols can 
    be implemented in Alox itself. 
  * Ranges are compiled to static arrays of Int with 2 members.
  * Regexes are compiled as byte strings.
  * When included inside a module, a def is only prefixed with that module's 
    name space.
  * Integers, floats and booleans are always passed by value. Others are 
    normally passed by address. 
  * Classes and Modules are not supported (since they will be implemented in 
    Alox). 
  * Records can be defined with Foo = record do ... end . A record acts a bit 
    like structs in C, but a are bit more powerful. Methods of the class are
    translated to statically called functions that take an instance of the 
    record's type as it's first (hidden) argument.        
  * All @instance_variables of the class must be defined before use with 
    field declarations like these: field :foo, <default value> 
    or field :foo, Typename. 
  * Inheritance is possibe, but statical. If you say Foo = record Bar do .. end, 
    all fields of Bar are included in Foo in such a way that calling calling
    any method of Bar on any instances of Foo will work. When using inheritance,
    the class Foo will use all methods of Bar that have not been overridden.
    constructors, like initialize, must be called automatically. Super works, 
    but again, only statically looks up the method to use at compile time.
  * Records suports inlining of their members. If you use an address as a 
    member, that adddress is merely a reference. However, arrays or other 
    records may be "inlined" into another staclass, so the resulting stacla 
    isa contiguous block of memory. Inline arrays are supported. An inline 
    array may either be statical, or, if it is dynamical, depend on the value 
    of another member of the stacla. (XXX: explain this better after     
    implementing it).      
  * All operators that are also available in C, work like they do in C.
  * Blocks are compiled down to anonymous (randomly named, local) functions.
  * Lexically scoped variables are passed separately as a hidden closure 
    argument. For example foo = 10  baz = quux.frotz { |fie| fie + foo } 
    will produce  _block_123(self, closure, fie, fai).    
  * You can include assembly in a special format.
  * There are special constructs for system calls.
  * There are special constructs for interfacing with C, to be defined later 
    (FFI or Ruby/DL like???)
      
  Design of the compiler
  ====================== 
  
  The compiler will perform several passes. 
  1) The parser and lexer is, for now at least, the exellent ruby_parser gem of 
  Zenspider.  The s-expressions generated are preprocessed, and then sent to 
  the right compiler for each dialect (Ruby or Alox).   
  2) The compiler then processes the syntax tree to a more specific semantic 
  tree for it's own semantics.
  3) The semantic tree from either dialect is compiled to virtual assembly, 
     and to an information file. The information file a bit like Pascal's 
     module file. It registers information about the compiled unit
  4) The virtual assembly is translated to real assembly, and then to object 
     code.
  5) If needed, linking is performed.
  
  
  Plan for implementation:
  ========================
  
  1) Implement Alox mode, starting with the semantic interpretation.
  2) Compile Alox mode semantics to i386 assembly for Linux OS.
  3) Implement basic classes for Ruby in Alox.
  4) Replace direct assembler with virtual assembler.
  5) Implement Ruby mode semantic interpretation.
    
    

  Copyright and Licence
  =====================
  
  Orurira is Copyright (C) 2009 Beoran beoran@rubyforge.org

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>
