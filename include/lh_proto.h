#ifndef LH_PROTO_H
#define LH_PROTO_H
/*
This file was autogenerated from src/lh.c
by bin/genproto
Please do not hand edit.
*/

/** Lua helper functions. */
#include <stdlib.h>
#include <string.h>
#include <lauxlib.h>
#include "eruta.h"
#include "str.h"
#include "lh.h"
#include "fifi.h"
// needed for console output for lua errors.
#include "widget.h"


/* Not declared in lauxlib.h somehow, but it exists... */
void luaL_openlibs (Lua *L);

/** Lua helper functions and macros. */
Lua * lh_new();

/** Frees a lua state if it's non-NULL. */
Lua * lh_free(Lua * lua);

/** Creates lua user data in which the pointer to data will be stored.
* You must set up the metatable first thoug lh_datainit and lh_datamethod
*/
void ** lh_pushdata(Lua *L, const char * name, void * data);

/** Gets the object at stack index index as a pointer to data */
void * lh_todata(Lua *L,  int index);

/** Gets the object at stack index index as a pointer to data. 
Performs type checking. */
void * lh_checkdata(Lua *L, const char * name, int index);

/** Gets the object on the top of the stack (first argument). Useful
for OOP-style methods or __gc metamethods. */
void * lh_getself(Lua *L, const char * name);

/** Makes it easier to parse the arguments a Lua function has received.
* Works in the spirit of scanf(), but with different specifiers.
* d : double *, i: int *, l : long *, s : char **, S strdupped char **, p
* userdata pointer. Retuns amount of arguments detected.
*/
int lh_scanargs_va(Lua *L, char * format, va_list args);

/** Makes it easier to parse the arguments a Lua function has received.
* Works in the spirit of scanf(), but with different specifiers.
* d : double *, i: int *, l : long *, s : char **, D strDupped into char **,
* S : STR ** (Allegro string),  p: userdata pointer.
* Retuns amount of arguments detected.
*/
int lh_scanargs(Lua *L, char * format, ...);

/** report errors to console  */
int lh_report_console(Lua *L, int status, void * console);

/** report errors to stderr  */
int lh_report_stderr(Lua *L, int status);

/**
* Executes a file in Eruta's data/script directory.
* Returns -1 if the file ws not found.
*/
int lh_dofile(Lua *L, const char * filename);

/** Executes a string in the lua interpreter and handles errors
* by putting atraceback on the stack
*
*/
int lh_dostring(Lua *L, const char * dorun);

/** Executes then named global function in the lua interpreter and 
* handles errors by putting a traceback on the stack
*
*/
int lh_dofunction(Lua *L, const char * funcname);

/** Executes then named global function in the lua interpreter and 
* handles errors by putting a traceback on the stack. Takes arguments.
*/
int lh_dofunction_va(Lua *L, const char * funcname,
                   const char * format, va_list args);

/**
* shows an error to stderr if res is nonzero
*/
int lh_showerror_stderr(Lua * lua, int res);

/**
* shows an error to console if res is nonzero
*/
int lh_showerror_console(Lua * lua, int res, void * console);

/**
* Executes a file in Eruta's data/script directory, and displays any errors
* on stderr. 
*/
int lh_dofile_stderr(Lua * lua, const char * filename);

/**
* Executes a file in Eruta's data/script directory, and displays any errors
* on console. 
*/
int lh_dofile_console(Lua * lua, const char * filename, void * console);

/**
* Executes a string and displays any errors
* on stderr 
*/
int lh_dostring_stderr(Lua * lua, const char * code);

/**
* Executes a function and displays any errors
* on console. 
*/
int lh_dofunction_console(Lua * lua, const char * name, void * console);

/**
* Executes a string and displays any errors
* on stderr 
*/
int lh_dofunction_stderr(Lua * lua, const char * name);

/**
* Executes a function and displays any errors
* on console. 
*/
int lh_dofunction_console_va(Lua * lua, const char * name, 
                             void * console, const char * format, va_list args);

/**
* Executes a string and displays any errors
* on stderr 
*/
int lh_dofunction_stderr_va(Lua * lua, const char * name, const char * format, va_list args);

/**
* Executes a string and displays any errors
* on console. 
*/
int lh_dostring_console(Lua * lua, const char * code, void * console);

/** Looks up the console in the lua state's registry and then reports to that,
 as code is executed. */
int lh_dostring_myconsole(Lua * lua, const char * code);

/** Looks up the console in the lua state's registry and then reports to that,
 as  the namef function is executed. */
int lh_dofunction_myconsole(Lua * lua, const char * name);

/** Calls a function with arguments, and log to the active console. */
int lh_dofunction_myconsole_args(Lua *L, const char * funcname,
                                const char * format, ...);

/** Pushes values on top of the lua stack with the given argument list. Uses
* a printf-like interface so it's easier to pass around arguments.
* Returns the amount of values pushed.
* Format can contain: 'd' double, 'i' int, 'b' boolean, 's', string
* 'S' STR (allegro string) , 'p' light user data, 'f': lua_CFunction,
* '0': nil, 'v': lua_pushvalue with integer index. 
*/
int lh_push_va(Lua *L, const char * format, va_list args);

/** Pushes values on top of the lua stack with the given arguments. Uses
* printf-like interface so it's easier to pass around arguments.
* Returns the amount of values pushed.
*/
int lh_push_args(Lua *L, const char * format, ...);

/** Calls a function  after first calling lh_push_va with the
* argument list. The function should already be on the stack.
* LUA_MULTRET is used as number of results
*/
int lh_call_va(Lua * L, const char * format, va_list args);

/** Calls a function  after first calling lh_push_va with the
* arguments. The function should already be on the stack.
*/
int lh_call_args(Lua * L, const char * format, ...);

/** Calls a function  after first calling lh_push_va with the
* argument list. The function should already be on the stack.
* LUA_MULTRET is used as number of results
*/
int lh_pcall_va(Lua * L, const char * format, va_list args);

/** Calls a function  after first calling lh_push_va with the
* arguments. The function should already be on the stack.
*/
int lh_pcall_args(Lua * L, const char * format, ...);

/** Calls a named global function, as per lh_call_va */
int lh_callglobal_va(Lua * L, const char * name,
                     const char * format, va_list args);

/** Calls a named global function, as per lh_call_args */
int lh_callglobal_args(Lua * L, const char * name,
                       const char * format, ...);

/** Calls a named global function for the lua interpreter,
show errors on stderr */
int lh_callglobalstderr_va(Lua * L, const char * name,
                        const char * format, va_list args);

/** Calls a named global function for the lua interpreter,
show errors on stderr */
int lh_callglobalstderr_args(Lua * L, const char * name,
                        const char * format, ...);

/** Registers the methods and metamethods of the named type. */
int lh_register_data(Lua *L, const char * name,
                     luaL_Reg * methods, luaL_Reg * meta);

/** Like lua_rawseti, but with a string key. */
void lh_rawsets(Lua *L, char * key, int index);

/** Like lua_rawgeti but with a string key */
void lh_rawgets(Lua *L, int index, char * key);

/**Calls luaL_checktype() with a LUA_TTABLE argument. */
void lh_checktable(Lua *L, int index);

/** Utility function that calls lua_rawgeti, and then lua_tointeger and lua_pop and returns the result. In other words, it gets an integer 
value at an integer index key from the table at index on the lua stack.
**/
int lh_geti(Lua *L, int index, int key);

/** Makes a new metatable for the given type name, and prepares it so the data will be able to given methods using the lh_datamethod function. If fun is not NULL, it sets the __gc value in the metatable to fun, so data of the given type will be correctly garbage collected. Must be called before calling
lh_datamethod.
*/
void lh_datainit(Lua *L, char * name, lua_CFunction fun);

/** adds a method to the given named user data type. */
void lh_datamethod(Lua *L, char * meta, char * name, lua_CFunction fun);

/** Gets a string that defines the name of the type at stack index index. */
const char * lh_typename(Lua *L, int index);

/** Walks over a table at index, calling the walker function as it goes.
* key will be at index -2, and value at index -1 
*/
void lh_tablewalk(Lua *L, int index,
                  lh_walker * walker, void * data);

/** Adds a global integer constant to the lua state */
void lh_globalint(Lua *L, const char *name, const int i);

/** Stores a C pointer in the registry with the given string key */
void lh_registry_putptr(Lua *L, const char * name, void * ptr);

/** Retrieves a c pointer from the registry with the given string key */
void * lh_registry_getptr(Lua *L, const char * name); 

#endif // LH_PROTO_H

