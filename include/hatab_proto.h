#ifndef HATAB_PROTO_H
#define HATAB_PROTO_H
/*
This file was autogenerated from src/hatab.c
by bin/genproto
Please do not hand edit.
*/

/** Hash function that hashes a C string. */
uint32_t hatab_hash_cstr(void * key);

/** Hash function that hashes a uint32_t. */
uint32_t hatab_hash_uint32(void * key);  

/** A hash table. The algorithm implemented is a coalesced hash table. */
struct Hatab_;
typedef struct Hatab_ Hatab;

/** Returns nonzero if the cellar is full, zero if it isn't. */
int hatab_cellarfull_p(Hatab * self);

/** Returns nonzero if the pails array is full, zero if it isn't. */
int hatab_pailsfull_p(Hatab * self);

/** Cleans up and empties a table. */
Hatab * hatab_done(Hatab * self);

/** Frees a hash table */
Hatab * hatab_free(Hatab * self);

/** Empties all entries in the table. */
Hatab * hatab_clear(Hatab * self);

/** Initializes the table with the given room and cellar space. */
Hatab * hatab_initroom(Hatab * self, HatabActs * acts, 
                        int pails, int cellars)
;

/** Allocates a Hatab. */
Hatab * hatab_alloc();

/** Initializes the hatab with default room and cellar space */
Hatab * hatab_init(Hatab * self, HatabActs * acts);

/** Makes a new hatab */
Hatab * hatab_newroom(HatabActs * acts, int pails, int cellars);

/** Makes a new hatab with default room and cellar space */
Hatab * hatab_new(HatabActs * acts);

/** Gets a value that matches key from a hash table. */
void * hatab_get(Hatab * self, void * key);

/** Removes a value that matches key from a hash table. Returns NULL if 
delete failed, or erased value. */
void * hatab_drop(Hatab * self, void * key);

/** Grows the hash table when needed. */
Hatab * hatab_grow(Hatab * self);

/** Stores a value in the hash table. */
void * hatab_put(Hatab * self, void * key, void * value);

#endif // HATAB_PROTO_H

