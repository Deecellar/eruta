#ifndef DYNAR_PROTO_H
#define DYNAR_PROTO_H
/*
This file was autogenerated from src/dynar.c
by bin/genproto
Please do not hand edit.
*/

/**
* Dynar is a DYNamic ARray of size elements each of elsz size.
* For simplicity, dynarr is exactly sized, that is,
* it does not allocate any extra elements but the amount requested.
* In other words it's capacity is equal to it's size.
*/
struct Dynar_;
typedef struct Dynar_ Dynar;

/** Gets the array's size. Returns 0 if self is NULL. */
size_t dynar_size(Dynar * self);

/** Gets the amount of elements in the vector. Returns 0 if self is NULL. */
size_t dynar_amount(Dynar * self);

/** Gets the array's element size.  Returns 0 if self is NULL. */
size_t dynar_elementsize(Dynar * self);

/** Frees the contents of an array. Has the same effect as emptying the array. Does not call a desctructor on any elements contained! */
Dynar * dynar_done(Dynar * self);

/** Frees an array. Returns NULL. */
Dynar * dynar_free(Dynar * self);

/** Allocates a new empty array.  */
Dynar * dynar_alloc();

/** Initializes an empty array with 0 elements of size elsz each. */
Dynar * dynar_initempty(Dynar * self, size_t elsz);

/** Allocates a new empty array for elements of size elsz each. */
Dynar * dynar_newempty(size_t elsz);

/** Changes the size of the dynamic array. Newsize must be >= 1. */
Dynar * dynar_size_(Dynar* self, size_t newsize);

/** Initializes a new array with a amount elements of size
elsz each. */
Dynar * dynar_init(Dynar * self, size_t amount, size_t elsz);

/** Initializes a new array with a capacity to store amount void* pointers.*/
Dynar * dynar_initptr(Dynar * self, size_t amount);

/** Allocates a new array with amount elements of size elsz each. */
Dynar * dynar_new(size_t amount, size_t elsz);

/** Allocates a new array that will be able to contain amount void * pointers.*/
Dynar * dynar_newptr(size_t amount);

/** Sets the amount of elements of the the array, but ony if
* amount bigger than the bigger than the current size.
* Returns NULL if the array was not grown, otherwise returns self.
*/
Dynar * dynar_grow(Dynar * self, size_t amount);

/** Checks if the index is smaller than the array's available room . */
int dynar_sizeindex_ok(Dynar * self, size_t index);

/** Checks if the int index is smaller than the array's available room. */
int dynar_index_ok(Dynar * self, int index);

/** Returns a pointer to the index-th element of the array.
Does no bounds checking! */
void * dynar_getraw_unsafe(Dynar * self, int index);

/** Copies dynar_elementsize(self) of bytes from the index-th element
of the array to out, which must be pointing to a bufer of at least
dynar_elementsize(self). Does no bounds checking!
Returns NULL on failure, out on success.
*/
void * dynar_getcopy_unsafe(Dynar * self, int index, void * out);

/** Copies dynar_elementsize(self) of bytes from the data pointed to
* by ptr into the location pointed to by index.
* Does no bounds checking!
*/
Dynar * dynar_putraw_unsafe(Dynar * self, int index, void * ptr);

/** Returns a pointer to the index-th element of the array.
Does bounds checking and return NULL if out of bounds */
void * dynar_getraw(Dynar * self, size_t index);

/** Returns a pointer to the index-th element of the array.
Does bounds checking and return NULL if out of bounds */
void * dynar_getcopy(Dynar * self, int index, void * ptr);

/** Copies the dynar_elementsize(self) of bytes from the data pointed to
* by ptr into the location pointed to by index.
* Does bounds checking and return NULL if ouut of bounds.
*/
Dynar * dynar_putraw(Dynar * self, size_t index, void * ptr);

/** Stores a pointer at the index of the array.
* Does bounds checking. dynar_elementsize(self) sould have been
* initialized as sizeof(void *) by using dynar_newptr
*/
void * dynar_putptr(Dynar * self, int index, void * ptr);

/** Returns a pointer that was stored at the index index of the array. */
void * dynar_getptr(Dynar * self, size_t index);

/** Copies the element that *ptr points to into this array at position
index */
void * dynar_putdata(Dynar * self, size_t index, void * ptr);

/** Returns a pointer to the index-th element of the array. */
void * dynar_getdata(Dynar * self, size_t index);

/** Iterates over the data. Call every_free when done. */
Every * dynar_every_data(Dynar * dynar);

/** Iterates over the pointers in this array. Call every_free when done. */
Every * dynar_every_ptr(Dynar * dynar);

#endif // DYNAR_PROTO_H

