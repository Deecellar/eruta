#ifndef ERUTA_DYNAR_H
#define ERUTA_DYNAR_H

#include <stdlib.h> // need size_t
// can use with every, so include the header 
#include "every.h"
#include "mem.h"

typedef struct Dynar_ Dynar;

typedef struct Lilis_ Lilis;

// get autogenerated function prototypes.
/* This file was generated with:
'cfunctions -c -aoff -n -w dynar_proto src/dynar.c' */
#ifndef CFH_DYNAR_PROTO
#define CFH_DYNAR_PROTO

/* From 'src/dynar.c': */

int dynar_size (Dynar * self );

int dynar_amount (Dynar * self );

int dynar_elementsize (Dynar * self );

Dynar * dynar_done (Dynar * self );

Dynar * dynar_destroy (Dynar * self , MemDestructor * destroy );

Dynar * dynar_free (Dynar * self );

Dynar * dynar_free_destroy (Dynar * self , MemDestructor * destroy );

/* Macro definitions for C extensions for Cfunctions. */

/* 
   Copyright (C) 1998 Ben K. Bullock.

   This header file is free software; Ben K. Bullock gives unlimited
   permission to copy, modify and distribute it. 

   This header file is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*/


#ifndef C_EXTENSIONS_H
#define C_EXTENSIONS_H

/* Only modern GNU C's have `__attribute__'.  The keyword `inline'
   seems to have been around since the beginning, but it does not work
   with the `-ansi' option, which defines `__STRICT_ANSI__'.  I expect
   that `__attribute__' does not work with `-ansi' either.  Anyway
   both of these failure cases are being lumped together here for the
   sake of brevity. */

#if defined (__GNUC__) && ( __GNUC__ >= 2 ) && ( __GNUC_MINOR__ > 4 ) && \
   ! defined (__STRICT_ANSI__)

/* Macro definitions for Gnu C extensions to C. */

#define X_NO_RETURN __attribute__((noreturn))
#define X_PRINT_FORMAT(a,b) __attribute__((format(printf,a,b)))
#define X_CONST __attribute__((const))
#define X_INLINE

#else /* Not a modern GNU C */

#define X_NO_RETURN 
#define X_PRINT_FORMAT(a,b) 
#define X_CONST

#endif /* GNU C */

/* The following `#define' is not a mistake.  INLINE is defined to
   nothing for both GNU and non-GNU compilers.  When Cfunctions sees
   `INLINE' it copies the whole of the function into the header file,
   prefixed with `extern inline' and surrounded by an `#ifdef
   X_INLINE' wrapper.  In order to inline the function in GNU C, only
   `X_INLINE' needs to be defined. There is also a normal prototype
   for the case that X_INLINE is not defined.  The reason for copying
   the function with a prefix `extern inline' into the header file is
   explained in the GNU C manual and the Cfunctions manual. */

#define INLINE
#define NO_RETURN void
#define NO_SIDE_FX
#define PRINT_FORMAT(a,b)
#define LOCAL

/* Prototype macro for `traditional C' output. */

#ifndef PROTO
#if defined(__STDC__) && __STDC__ == 1
#define PROTO(a) a
#else
#define PROTO(a) ()
#endif /* __STDC__ */
#endif /* PROTO */

#endif /* ndef C_EXTENSIONS_H */
Dynar * dynar_alloc PROTO ((void));

Dynar * dynar_initempty (Dynar * self , int elsz );

Dynar * dynar_newempty (int elsz );

Dynar * dynar_size_ (Dynar * self , int newsize );

Dynar * dynar_init (Dynar * self , int amount , int elsz );

Dynar * dynar_initptr (Dynar * self , int amount );

Dynar * dynar_new (int amount , int elsz );

Dynar * dynar_newptr (int amount );

Dynar * dynar_grow (Dynar * self , int amount );

int dynar_sizeindex_ok (Dynar * self , int index );

int dynar_index_ok (Dynar * self , int index );

void * dynar_getraw_unsafe (Dynar * self , int index );

void * dynar_getcopy_unsafe (Dynar * self , int index , void * out );

Dynar * dynar_putraw_unsafe (Dynar * self , int index , void * ptr );

void * dynar_getraw (Dynar * self , int index );

void * dynar_getcopy (Dynar * self , int index , void * ptr );

Dynar * dynar_putraw (Dynar * self , int index , void * ptr );

void * dynar_putptr (Dynar * self , int index , void * ptr );

void * dynar_getptr (Dynar * self , int index );

void * dynar_putdata (Dynar * self , int index , void * ptr );

void * dynar_getdata (Dynar * self , int index );

Every * dynar_everynow_data (Every * every );

Every * dynar_everynow_ptr (Every * every );

Every * dynar_everyinit_data (Every * every );

Every * dynar_everynext_data (Every * every );

void * dynar_everyput_data (Every * every , void * data );

void * dynar_everydone (Every * every );

Every * dynar_everyinit_ptr (Every * every );

Every * dynar_everynext_ptr (Every * every );

void * dynar_everyput_ptr (Every * every , void * data );

Every * dynar_every_data (Dynar * dynar );

Every * dynar_every_ptr (Dynar * dynar );

void * dynar_each_ptr (Dynar * self , EachDo * eachdo , void * extra );

void * dynar_walkdata (Dynar * self , EachDo * eachdo , void * extra );

Lilis * lilis_freetail (Lilis * self );

Lilis * lilis_done (Lilis * self );

Lilis * lilis_free (Lilis * self );

Lilis * lilis_alloc PROTO ((void));

Lilis * lilis_init (Lilis * self , Lilis * next , Lilis * prev , void * data );

Lilis * lilis_initempty (Lilis * self );

Lilis * lilis_new (Lilis * next , Lilis * prev , void * data );

Lilis * lilis_newempty PROTO ((void));

Lilis * lilis_add (Lilis * self , Lilis * other );

Lilis * lilis_addnew (Lilis * self , void * data );

Lilis * lilis_removenext (Lilis * self );

Lilis * lilis_remove (Lilis * self );

Lilis * lilis_erase (Lilis * self );

Lilis * lilis_erasenext (Lilis * self );

Lilis * lilis_next (Lilis * self );

Lilis * lilis_previous (Lilis * self );

void * lilis_data (Lilis * self );

#endif /* CFH_DYNAR_PROTO */




#endif


